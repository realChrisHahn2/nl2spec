Natural Language;Label;Final Translation;subtranslations
Every a is eventually followed by a e.;G(a -> F e);G((a -> F(e)));{"a": "a", "e": "e", "every a": "a", "is eventually followed by a e": "F e", "every": "G", "eventually": "F", "followed by": "->"}
It is never the case that a and b hold at the same time.;G(!(a & b));G(!((a & b)));{"a and b hold at the same time": "a & b", "never": "G"}
Whenever a is enabled, b is enabled three steps later.;G(a -> X (X (X b)));G((a -> X(X(X(b)))));{"b is enabled three steps later": "X X X b", "b is enabled": "b", "never": "~", "a is enabled": "a", "whenever": "G", "later": "X"}
e must hold everywhere until from some point on, d holds infinitely often.;e U (G (F d));(G(e) U F(G(F(d))));{"until from some point on": "F", "from some point on": "F", "e must hold everywhere": "G e", "d holds infinitely often": "G F d"}
If b holds at some point, a has to hold somewhere beforehand.;(F b) -> (!b U (a & !b));(b -> F(a));{"if b holds at some point, a has to hold somewhere": "F b -> G (a -> X a)", "if b holds at some point": "b", "a has to hold somewhere beforehand": "F a"}
Whenever a holds, b holds as well.;G(a -> b);G((a & b));{"a holds": "a", "b holds as well": "b", "whenever": "G", "never": "~"}
Both a and b hold in every time step.;G (a && b);G((a & b));{"in every time step": "G", "every time step": "G", "a and b hold": "a & b"}
a holds always and whenever b holds, c does not hold.;G a && G(b -> !c);(G(a) & (b -> !(c)));{"a holds always": "a", "whenever b holds": "b", "and": "&", "a holds": "a", "b holds": "b", "whenever": "->", "c does not hold": "~c", "always": "G"}
If it is the case that every a is eventually followed by a b, then c needs to holds infinitely often.;G(a -> F b) -> G F c;(G((a -> F(b))) -> G(F(c)));{"c needs to hold infinitely often": "GF c", "if every a is eventually followed by a b, then c needs to hold infinitely often": "G (a -> F b) -> GF c", "c needs to holds infinitely often": "GF c", "every a is eventually followed by a b": "G (a -> F b)"}
If a holds infinitely often, then b holds infinitely often as well.;G F a -> G F b;(G(F(a)) -> G(F(b)));{"a holds": "a", "b holds": "b", "infinitely often": "F", "if a holds infinitely often then b holds infinitely often": "a -> b", "a holds infinitely often": GF a", "b holds infinitely often as well": "GF b", "if a holds infinitely often, then b holds infinitely often: "GF a -> GF b"}
Either a or b holds infinitely often;G F a || G F b;G(F((a | b)));{"a or b holds": "a | b", "infinitely often": "GF", "either a or b holds": "a | b"}
a never holds from some point in time on.;F G ! a;G(!(a));{"a holds": "a", "never": "~", "from some point in time on": "G"}
Whenever a and b do not hold, c holds eventually.;G (!(a && b) -> F c);(!((a & b)) -> F(c));{"a and b do not hold": "~(a & b)", "whenever a and b do not hold, c holds eventually": "~ (a & b) -> F c", "and": "&", "do not hold": "~", "holds eventually": "F", "whenever": "->", "c holds eventually": "F c"}
a and b never occur at the same time but one of them holds in every time step.;G(!(a &&b)) && G(a || b);(!((a & b)) -> G((a | b)));{"a and b never occur at the same time": "~(a & b)", "but": "->", "one of them holds in every time step": "G (a | b)"}
Whenever the inputs a and b are the same, the outputs c and d are the same.;G ((a <-> b) -> (c <-> d));(G((a <-> b)) -> (c <-> d));{"inputs a and b are the same": "a <-> b", "outputs c and d are the same": "c <-> d", "never": "F", "followed by": "->", "are the same": "<->", "the same": "<->", "whenever": "G", "inputs a and b": "a & b", "outputs c and d": "c & d"}
a can only happen if b happend before;(! a) U b;((b U false) -> a);{"b happend before": "b U false", "if b happened before then a can only happen": "b -> a", "if b happend before": "b", "if b happened before": "b U X a", "if b happened before than a can only happen": "b U X a -> a", "a can only happen": "a"}
Once a happened, b won't happen again.;G (a -> X G ! b);(F(a) -> G(!(b)));{"never": "G", "again": "F", "a happened": "a", "will not happen again": "~", "not": "~", "once a happened": "F a", "b will not happen again": "G ~ b", "once": "F"}
a releases b;(b U (b & ! a)) | G b;(a & b);{}
a and b won't occur at the same time;G !(a & b);!((a & b));{"a and b": "a & b", "will not occur at the same time": "~(a & b)"}
Whenever a holds and b holds in the next step, then c holds one step after b.;G (a && X b -> X X c);(a & b X) -> (c X b);{"never": "~", "one step after": "X", "c holds one step after b": "c X b", "whenever": "->", "then": "->", "a holds": "a", "b holds in the next step": "b X", "and": "&"}
Whenever a holds, b holds eventually from the next step on.;G (a -> X F b);(a -> X(F(b)));{"whenever a holds, b holds eventually from the next step on": "a -> X (F b)", "whenever": "->", "from the next step on": "X", "a holds": "a", "b holds eventually from the next step on": "X (F b)"}
a holds in every fifth step.;a && G (a -> X ! a && X X ! a && X X X ! a && X X X X ! a && X X X X X a);G(X(X(X(X(a)))));{"every fifth step": "G", "a holds": "a"}
Either a holds infinitely often or b holds in the next step.;G F a || X b;(G(F(a)) | X(b));{"in the next step": "X", "or": "|", "either": "|", "infinitely often": "F", "a holds": "a", "b holds in the next step": "X b"}
a will hold at all instances.;G (a);G(a);{"a will hold at all instances": "a", "a will hold": "a", "at all instances": "G"}
Whenever a holds, b must hold in the next two steps;G (a -> (b | X b));(a -> X(X(b)));{"whenever a holds, b must hold in the next two steps": "a -> X (X b)", "b must hold in the next two steps": "X (X b)", "whenever": "->", "must": "->", "in the next two steps": "X", "a holds": "a"}
One of the following aps will hold at all instances: a,b,c;G (a | b | c);G((a | b | c));{"will hold at all instances": "G", "one of the following aps will hold at all instances": "G", "a,b,c": "a | b | c"}
If a holds b will eventually hold;G (a -> F b);(a -> F(b));{"a holds": "a", "b will eventually hold": "F b", "if a holds then b will eventually hold": "a -> F b"}
a must always hold, but if is execeeds, it allow two timestamps to recover.;! G (! (a && X a));(G(a) & e & F((t1 & t2)));{"it allow two timestamps to recover": "F (F (t1 & t2))", "must always hold": "G", "if": "->", "allow": "->", "to": "->", "exceeds": "b", "it": "c", "two timestamps": "d", "if is exceeds": "e", "a must always hold": "G a", "but": "&"}
not a holds at most two timestamps;! G (! (a && X a));!((a & !(X(X(a)))));{"at most two timestamps": "~(X(X a))", "not": "~", "not a holds": "~ a", "a holds": "a"}
a can only hold every three timestamps;G ( a -> (X !a | XX !a | XXX !a));(a U a U a);{"can only hold": "->", "only": "U", "at most": "U", "hold": "X", "a can only hold": "a", "three timestamps": "3"}
Every a is followed by a b.;G ( a -> X b);G((a -> F(b)));{"b": "b", "every": "G", "eventually": "F", "is followed by": "->", "a b": "a b", "every a": "a", "followed by": "->"}
Eventually a and b hold.;F (a && b);F((a & b));{"a and b hold": "a & b", "eventually": "F"}
Both a and b hold eventually.;F a && F b;F((a & b));{"a holds": "a", "b holds": "b", "both": "&", "a and b hold": "a & b", "eventually": "F"}
It is always the case that a is the same as b in the next step.;G (a <-> X b);G((a <-> b));{"a is the same as b": "a <-> b", "in the next step": "X", "always": "G"}
If b holds then, in the next step, c holds until a holds or always c holds;b -> X ((c U a) || G c);(b -> X(((c U a) | G(c))));{"until a holds": "a U c", "if b holds then, in the next step, c holds until a holds": "b -> X (c U a | G c)", "c holds until a holds": "c U a", "if b holds then c holds until a holds or always c holds": "b -> (c U a | G c)", "or": "|", "if b holds then": "b ->", "c holds": "c", "b holds: "b", "in the next step": "X", "always c holds": "G c"}
a holds until b holds or always a holds;(a U b) || G a;(a U (b | G(a)));{"or": "|", "until": "U", "a holds": "a", "b holds": "b", "always": "G"}